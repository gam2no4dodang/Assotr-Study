#include <iostream>

/*
전역변수 선언시 g_ 를 붙여주는 이유는 전역변수라고 표현하기 위해서이다.
이렇게 전역변수를 선언하면 이 선언 아래에 있는 코드에서는 이 변수를
공용으로 사용할 수 있다.
전역변수는 값을 초기화 안해주면 자동으로 0으로 초기화가 된다.
지역변수는 해당 함수가 종료되면 스택에서 정리가 되지만
전역변수는 프로그램이 종료될 때 메모리에서 정리가 된다.
*/

int g_Number = 100;

int Add(int Number1, int Number2)
{
	return Number1 + Number2 + g_Number;
}

int Add(int Num1, int Num2, int Num3)
{
	return Num1 + Num2 + Num3 + g_Number;
}

/*
함수의 오버로딩 : 같은 이름으로 함수를 만들어줄때 인자의 개수 혹은 타입이
서로 다를 경우 같은 이름으로 함수를 정의하는 것이 가능하다.
이를 함수의 오버로딩이라고 한다.
반환타입은 함수의 오버로딩에 영향을 줄 수 없다.
*/
float Add(float Number1, float Number2)
{
	return Number1 + Number2;
}

//int Add(float Number1, float Number2)
//{
//	return Number1 + Number2;
//}

/*
함수의 인자는 호출시 값을 넣어주어야 한다.
하지만 함수의 디폴트 인자를 사용하게 되면 값을 넣어주어도 되고 안넣어주어도 된다.
함수의 디폴트 인자는 함수의 인자에 이 인자가 가질 기본값을 정의해주어서
외부에서 함수를 호출할때 값을 넣어주면 해당 값으로 설정을 하고 값을 비워두면
기본값으로 설정이 되게 된다.
디폴트 인자는 함수의 인자중 가장 오른쪽부터 설정해야한다.
오른쪽 인자는 디폴트 인자가 아니고 왼쪽 인자가 디폴트 인자일 경우 에러가 발생한다.
*/
int Add1(int Number1, int Number2 = 20)
{
	return Number1 + Number2;
}

/*
위의 함수와 아래의 함수는 두 함수 모두 인자 1개만 넣어주어도 동작이
되기 때문에 함수를 호출시 인자를 1개만 넣어서 호출하게 되면 둘중 어떤
함수를 동작시켜야 할지 판단할 수 없기 때문에 에러가 발생한다.
*/
//int Add1(int Number1)
//{
//	return Number1;
//}

/*
전역변수 : 함수의 외부에서 선언된 변수를 의미한다.
함수의 외부에 선언되어 있기 때문에 전역변수가 선언된 부분 아래에 존재하는
함수들에서 이 변수를 공용으로 사용할 수 있게 된다.

C++의 메모리 영역 : 스택영역, 데이터영역, 힙영역, 코드영역

스택영역 : 함수의 인자 혹은 함수의 내부에서 선언된 변수들의 메모리가 
할당되는 영역 이다.
함수의 내부에서 선언된 변수를 지역변수하고 한다.
함수의 인자는 매개변수라고 한다.

데이터영역 : 전역변수, 정적(static)변수들의 메모리가 할당되는 영역이다.

변수 타입 앞에 static을 붙여주면 해당 변수는 정적변수가 된다.
정적변수는 처음 한번만 초기화가 되고 그 다음부터는 초기화 코드가 무시된다.
정적변수는 초기화를 안하면 자동으로 0으로 초기화가 된다.
정적변수는 지역변수에 static을 붙여서 만들어주어도 해당 함수가 종료되면
메모리를 제거하는것이 아닌 그대로 유지가 되고 프로그램이 종료가 되어야 메모리에서 제거가 된다.

힙영역 : 동적할당된 메모리가 할당되는 영역이다.
필요할때 공간을 할당하고 원할때 메모리를 제거할 수 있다.
동적할당시 문제가 생길 수 있는 부분으로 메모리 단편화가 있다.

코드영역 : 작성한 코드를 컴파일러가 바이너리코드(0, 1 로 구성된 코드) 로
만들어주고 이 바이너리코드를 이용해서 실행파일을 만들어준다.
실행파일을 더블클릭해서 실행을 하게 되면 해당 프로그램이 동작 되는데
이때 실행파일을 구성하는 바이너리코드가 메모리에 저장되게 된다.
이렇게 코드가 저장되는 영역을 코드영역 이라고 한다.
*/

/*
함수포인터 : 함수도 메모리 주소가 존재한다.
왜냐하면 바이너리코드가 코드영역에 올라가게 되면 코드를 구성하고 있는
각 함수들도 메모리에 저장이 되기 때문에 주소를 가질 수 있게 되는 것이다.
실제 우리가 함수를 호출을 한다는 의미는 해당 메모리 주소로 이동하여 코드를
동작시키라는 의미가 된다.
그렇다면 함수의 주소를 알 수 있어야 하는데 함수의 이름이 곧 해당함수의
메모리 주소가 된다.
*/

//재귀호출 : 함수의 내부에서 자신을 다시 호출해주는 기능이다.

void Test()
{
	int Number = 100;

	std::cout << "Test : " << Number << std::endl;

	++Number;
}

void TestStatic()
{
	static int Number = 100;

	std::cout << "TestStatic : " << Number << std::endl;

	++Number;
}

int main()
{
	std::cout << Add(10, 20) << std::endl;
	std::cout << Add(30, 40) << std::endl;
	std::cout << Add(3.14f, 21.374f) << std::endl;

	std::cout << Add1(50, 60) << std::endl;
	std::cout << Add1(50) << std::endl;

	Test();
	Test();
	Test();

	TestStatic();
	TestStatic();
	TestStatic();

	std::cout << Test << std::endl;
	std::cout << TestStatic << std::endl;

	/*
	함수의 포인터 타입은 반환타입, 인자에 영향을 받는다.
	Test나 TestStatic은 void 반환타입에 인자가 없디.
	반환타입(*포인터명)(인자타입); 의 형태로 함수 포인터 변수를 선언할 수 있다.
	*/
	void(*Func)() = Test;

	Func();

	Func = TestStatic;

	Func();

	int(*Func1)(int, int) = Add;

	float(*Func2)(float, float) = Add;

	std::cout << Func1(10, 20) << std::endl;
	std::cout << Func2(3.14f, 33.22f) << std::endl;

}
