
#include <iostream>

int main()
{
	/*
	메모리 크기보다 값을 벗어나게 입력하면 앞이나 뒤로 넘어가서 표현됨(상수) = 버그 오류 발생
	 short : 2byte -32768 ~ 32767이므로 -32769는 -32768을 넘어감으로 그 다음인 32767이 출력됨
	 */
	short	Number = -32769;

	Number = 332;

	std::cout << Number << std::endl;

	/*
	변수 사용시
	변수 이름 = 타입;
	출력시 타입으로 출력
	*/
	bool	Test1 = true;

	std::cout << Test1 << std::endl;


	//char : 문자 하나만 저장함, 여러개 저장x, 저장시 'A' 이런식으로 작은 따옴표 안에 저장 

	/*
	변수는 선언과 동시에 값을 지정해도 되지만 언제든 값을 바꿀 수 있다.

	변수는 값의 대입이 없을 경우 쓰레기가 들어가있음, 그러므로 항상 변수의 값을 초기화 해두고 사용하자

	변수는 선언을 하면 기본으로 signed 가 된다.
	모든 변수 타입들은 unsigned 키워드를 이용해서 - 값을 + 값으로 변환하여 사용할 수 있다.
	ex)
	short은 -32768 ~ 32767 이다.
	unsigned 를 하게 되면 0 ~ 65535 까지 표현이 가능해진다.

	unsigned 변수 이름 = 타입;
	*/
	unsigned short Number3 = -1;

	std::cout << Number3 << std::endl;

	/*
	상수 : 한번 값을 지정하면 변경불가, const 키워드를 이용하면 변수를 상수로 변환가능
	const 변수 이름 = 타입;
	
	Q. 그냥 변수로 쓰고 값을 안바꾸면 안됨?
	A. 팀 작업시 남들이 보기에 일반 변수로 보이면 바꿔도 된다고 인식 할 수 있음.
	   그러므로 상수로 바꿔놓아야 문제가 안생김 안그럼 본인 책임.
	*/
	const int	Number4 = 202020;
	const unsigned int Number5 = 29828283; //이렇게도 사용 가능

	//연산자

	/*
	사칙연산자 : +, -, /, *, %, ++, --
	% : 나누고 나머지 구해줌
	++ : 1증가, 상수x 변수에 사용해야함
	-- : 1감소, 상수x 변수에 사용해야함

	일반 수학과 비슷하고 소괄호만 존재
	나눗셈은 연산시 A와 B가 모두 정수라면 소수점 자리가 모두 잘리고 정수 부분만 값으로 나옴
	나눗셈보다 곱셈이 더 편리하게 작동됨으로 곱셈으로 처리 가능시 곱셈으로 하자
	앞쪽에 ++, -- 를 붙이면 먼저 증감/감소 후 그 값을 출력하게된다.
	뒷쪽에 ++, -- 를 붙이면 출력 후에 증감/감소 하게된다.
	*/
	std::cout << "10 / 3 = " << 10 / 3 << std::endl;

	// 3.0f = 3.f
	std::cout << "10 / 3 = " << 10 / 3.0f << std::endl;

	std::cout << "10 % 3 = " << 10 % 3 << std::endl;

	int	Number6 = 100;

	std::cout << Number6++ << std::endl;
	std::cout << Number6 << std::endl;

	/*
	관계연산자 : <, >, <=, >=, ==, !=
	== : 같다.
	!= : 다르다.

	결과값이 true, false 로 나오게된다.
	ex)
	10 < 20 = true
	10 > 20 = false
	10 <= 20 = true
	10 >= 20 = false
	10 == 20 = false
	10 != 20 = true
	*/
	std::cout << "10 < 20 = " << (10 < 20) << std::endl;
	std::cout << "10 > 20 = " << (10 > 20) << std::endl;
	std::cout << "10 <= 20 = " << (10 <= 20) << std::endl;
	std::cout << "10 >= 20 = " << (10 >= 20) << std::endl;
	std::cout << "10 == 20 = " << (10 == 20) << std::endl;
	std::cout << "10 != 20 = " << (10 != 20) << std::endl;

	/*
	논리연산자 : AND(&&), OR(||), NOT(!)
	AND(&&) : A, B 둘다 참일 경우 참, 아닐시 거짓
	OR(||) : A, B 둘중 하나만 참이여도 참, 아닐시 거짓
	NOT(!) : 하나에 대한 결과가 반대로

	A	B	AND	OR
	0	0	0	0
	1	0	0	1
	0	1	0	1
	1	1	1	1

	A	NOT
	0	1
	1	0
	*/
	std::cout << "false && false = " << (false && false) << std::endl;
	std::cout << "true && false = " << (true && false) << std::endl;
	std::cout << "false && true = " << (false && true) << std::endl;
	std::cout << "true && true = " << (true && true) << std::endl;

	std::cout << "false || false = " << (false || false) << std::endl;
	std::cout << "true || false = " << (true || false) << std::endl;
	std::cout << "false || true = " << (false || true) << std::endl;
	std::cout << "true || true = " << (true || true) << std::endl;

	std::cout << "!false = " << !false << std::endl;
	std::cout << "!true = " << !true << std::endl;

	/*
	10진수 : 0 ~ 9 사이의 숫자를 조합해 사용
	2진수 : 0 ~ 1 사이의 숫지를 조합해 사용
	8진수 : 0 ~ 7 사이의 숫자를 조합해 사용
	16진수 : 0 ~ 15 사이의 숫자를 조합해 사용, 0 ~ 9 까지는 일반 숫자, 10 ~ 15는 알파벳 a ~ f 사용
	a : 10, b : 11, c : 12, d : 13, e : 14, f :15 
	ex)
	0x11, 0xb = 16진수

	진수끼리 서로 변환 가능

	10진수 123을 2진수와 16진수로 변환해보자.
	2진수로 변환. 10진수를 2로 계속 나누어서 몫과 나머지를 구한다.
	123 / 2 = 61 -- 1
	61 / 2 = 30 --- 1
	30 / 2 = 15 --- 0
	15 / 2 = 7 ---- 1
	7 / 2 = 3 ----- 1
	3 / 2 = 1 ----- 1

	1  1  1  1 0 1 1
	64 32 16 8 4 2 1
	64 + 32 + 16 + 8 + 2 + 1 = 123

	1111011

	반대로 2진수를 10진수로 변환시 
	오른쪽부터 2의 n승으로 값을 구하고 1인 부분만 더한다.
	1  1  1  1 0 1 1
	64 32 16 8 4 2 1
	64 + 32 + 16 + 8 + 2 + 1 = 123

	16진수 1자리 = 2진수 4자리
	2진수의 가장 오른쪽부터 4자리씩 분리한다.
	왼쪽 부분이 자리수가 부족하다면 0을 왼쪽에 채워준다.
	각각 2의 n승 값을 구하고 1인 부분만 더해준다.
	0111 / 1011
	8421   8421

	0x7b

	반대로 16진수를 2진수로 변환시
	10진수 처럼 나누어주고 2진수화 해준다.
	0x7b
	11 / 2 = 5 -- 1
	5 / 2 = 2 --- 1
	2 / 2 = 1 --- 0

	7 / 2 = 3 --- 1
	3 / 2 = 1 --- 1
	0111 / 1011
	*/

	/*
	비트단위 논리연산자 : AND(&), OR(|), NOT(~), XOR(^)
	AND(&) : A, B 둘다 참일 경우 참, 아닐시 거짓
	OR(|) : A, B 둘중 하나만 참이여도 참, 아닐시 거짓
	NOT(~) : 하나에 대한 결과가 반대로
	XOR(^) : 서로 같으면 거짓, 다르면 참

	A	B	AND	OR XOR
	0	0	0	0   0
	1	0	0	1   1
	0	1	0	1   1
	1	1	1	1   0

	A	NOT
	0	1
	1	0

	ex)
	99 / 2 = 49 -- 1
	49 / 2 = 24 -- 1
	24 / 2 = 12 -- 0
	12 / 2 = 6 --- 0
	6 / 2 = 3 ---- 0
	3 / 2 = 1 ---- 1

	99 :  1100011
	123 : 1111011

	123 & 99 = 99
	 1111011
	&1100011
	 1100011

	123 | 99 = 123
	 1111011
	|1100011
	 1111011

	~123 =
	~00000000 00000000 00000000 01111011
	 11111111 11111111 11111111 10000100

	123 ^ 99 = 123
	 1111011
	^1100011
	 0011000
	*/
	std::cout << "123 & 99 = " << (123 & 99) << std::endl;
	std::cout << "123 | 99 = " << (123 | 99) << std::endl;
	std::cout << "~123 = " << ~123 << std::endl;
	std::cout << "123 ^ 99 = " << (123 ^ 99) << std::endl;

	return 0;
}
